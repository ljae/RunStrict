import random
import uuid
from datetime import datetime, timedelta

# Constants
HEX_LIST = [
    "89283472843ffff", "8928347284bffff", "8928347284fffff", "89283472853ffff", "8928347285bffff",
    "892834728c3ffff", "892834728cbffff", "892834728cfffff", "892834728dbffff", "89283472a03ffff",
    "89283472a13ffff", "89283472a17ffff", "89283472a1bffff", "89283472a83ffff", "89283472a87ffff",
    "89283472a8bffff", "89283472a8fffff", "89283472a93ffff", "89283472a97ffff", "89283472a9bffff",
    "89283472ab3ffff", "89283472abbffff", "89283472ac3ffff", "89283472ac7ffff", "89283472acbffff",
    "89283472acfffff", "89283472ad3ffff", "89283472ad7ffff", "89283472adbffff", "89283472e03ffff",
    "89283472e07ffff", "89283472e0bffff", "89283472e0fffff", "89283472e23ffff", "89283472e27ffff",
    "89283472e2bffff", "89283472e2fffff", "89283472e33ffff", "89283472e37ffff", "89283472e3bffff",
    "89283472e47ffff", "89283472e4fffff", "89283472e63ffff", "89283472e67ffff", "89283472e6bffff",
    "89283472e6fffff", "89283472e73ffff", "89283472e77ffff", "89283472e7bffff"
]

# Split hexes
HEXES_RED = HEX_LIST[:20]
HEXES_BLUE = HEX_LIST[20:35]
HEXES_PURPLE = HEX_LIST[35:]

PREFIXES = ["Speed", "Turbo", "Night", "Ghost", "Iron", "Zen", "Sky", "Shadow", "Neon", "Cyber", 
            "Rapid", "Flash", "Storm", "Thunder", "Solar", "Lunar", "Terra", "Aqua", "Blaze", "Frost",
            "Hyper", "Sonic", "Ultra", "Mega", "Giga", "Quantum", "Cosmic", "Astro", "Stellar", "Nova"]
SUFFIXES = ["Runner", "Stride", "Pace", "Dash", "Sprint", "Walker", "Jogger", "Racer", "Track", "Path", 
            "Way", "Road", "Street", "Lane", "Mile", "Km", "Foot", "Legs", "Soul", "Heart",
            "Force", "Power", "Energy", "Spirit", "Mind", "Body", "Flow", "Motion", "Move", "Go"]

MANIFESTOS = [
    "Run or die trying", "Pace is grace", "Born to run", "Chasing the horizon", "Never stop moving",
    "Speed is life", "Endurance is key", "Run free", "Hex hunter", "Territory taker",
    "Red team rules", "Blue wave incoming", "Purple chaos reigns", "Just one more mile", "Pain is weakness leaving",
    "Sweat is glory", "Miles to go", "On the run", "Fast and furious", "Slow and steady",
    "Run hard", "Run smart", "Run fast", "Run long", "Run deep",
    "Run wild", "Run strong", "Run true", "Run bold", "Run brave"
]

def generate_name(i):
    p = PREFIXES[i % len(PREFIXES)]
    s = SUFFIXES[(i // len(PREFIXES) + i) % len(SUFFIXES)]
    return f"{p}{s}{i}" # Ensure uniqueness with index if needed, but let's try to be cleaner
    # Actually, let's just use a deterministic shuffle or selection
    # 30 prefixes * 30 suffixes = 900 combos.
    # We need 100.
    
    # Deterministic pseudo-random
    random.seed(i)
    p = random.choice(PREFIXES)
    s = random.choice(SUFFIXES)
    # Ensure no duplicates in a real run, but for this script we'll just append ID if collision (unlikely with 900 space)
    return f"{p}{s}"

# Generate unique names
NAMES = set()
FINAL_NAMES = []
for i in range(100):
    name = generate_name(i)
    while name in NAMES:
        name = generate_name(i + 1000)
    NAMES.add(name)
    FINAL_NAMES.append(name)

def get_uuid(i):
    return f"aaaaaaaa-0000-0000-0000-{i:012d}"

def get_run_uuid(bot_i, run_j):
    return f"bbbbbbbb-{bot_i:04x}-{run_j:04x}-0000-000000000000"

sql = []
sql.append("-- ============================================================")
sql.append("-- RunStrict Simulation Seed (100 bots)")
sql.append("-- Generated by Antigravity")
sql.append("-- ============================================================")
sql.append("")
sql.append("BEGIN;")
sql.append("")
sql.append("-- 1. Clean up any previous sim data")
sql.append("DELETE FROM auth.users WHERE email LIKE 'bot%@runstrict.test';")
sql.append("")

# 2. Auth Users
sql.append("-- 2. Insert auth.users")
sql.append("INSERT INTO auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, raw_app_meta_data, raw_user_meta_data, is_sso_user, is_anonymous, created_at, updated_at)")
sql.append("VALUES")

auth_values = []
for i in range(100):
    uid = get_uuid(i)
    email = f"bot{i:03d}@runstrict.test"
    auth_values.append(f"  ('00000000-0000-0000-0000-000000000000', '{uid}', 'authenticated', 'authenticated', '{email}', '$2a$10$SimulatedPasswordHashForTestingOnly000000000000000000000', NOW(), '{{\"provider\":\"email\",\"providers\":[\"email\"]}}'::jsonb, '{{}}'::jsonb, false, false, NOW(), NOW())")

sql.append(",\n".join(auth_values) + ";")
sql.append("")

# 3. Public Users
sql.append("-- 3. Insert public.users")
sql.append("INSERT INTO public.users (id, name, team, avatar, season_points, manifesto, home_hex_start, home_hex, season_home_hex, sex, birthday)")
sql.append("VALUES")

public_values = []
for i in range(100):
    uid = get_uuid(i)
    name = FINAL_NAMES[i]
    
    if i < 40: team = 'red'
    elif i < 80: team = 'blue'
    else: team = 'purple'
    
    manifesto = MANIFESTOS[i % len(MANIFESTOS)]
    sex = ['male', 'female', 'other'][i % 3]
    # Birthday 1985-2005
    year = 1985 + (i % 21)
    month = (i % 12) + 1
    day = (i % 28) + 1
    birthday = f"{year}-{month:02d}-{day:02d}"
    
    public_values.append(f"  ('{uid}', '{name}', '{team}', 'ðŸƒ', 0, '{manifesto}', '89283472a93ffff', '89283472a93ffff', '89283472a93ffff', '{sex}', '{birthday}')")

sql.append(",\n".join(public_values) + ";")
sql.append("")

# 4. Update Hexes
sql.append("-- 4. Update hexes for team variety")
# Blue
blue_hex_str = "', '".join(HEXES_BLUE)
sql.append(f"UPDATE public.hexes SET last_runner_team = 'blue', last_flipped_at = NOW() - INTERVAL '2 hours' WHERE id IN ('{blue_hex_str}');")
# Purple
purple_hex_str = "', '".join(HEXES_PURPLE)
sql.append(f"UPDATE public.hexes SET last_runner_team = 'purple', last_flipped_at = NOW() - INTERVAL '1 hour' WHERE id IN ('{purple_hex_str}');")
# Red (remaining) - optional update to ensure timestamp, but prompt says "Keep ~20... UPDATE not needed" for color, maybe just timestamp?
# Let's leave Red as is or update timestamp if needed. Prompt says "Keep ~20... (UPDATE not needed)".
sql.append("")

# 5. Hex Snapshot
sql.append("-- 5. Rebuild hex_snapshot for today")
sql.append("DELETE FROM public.hex_snapshot WHERE snapshot_date = '2026-02-17';")
sql.append("INSERT INTO public.hex_snapshot (hex_id, last_runner_team, snapshot_date, parent_hex, last_run_end_time)")
sql.append("SELECT id, last_runner_team, '2026-02-17', parent_hex, last_flipped_at FROM public.hexes;")
sql.append("")

# 6. Run History
sql.append("-- 6. Insert run_history")
sql.append("INSERT INTO public.run_history (id, user_id, run_date, start_time, end_time, distance_km, duration_seconds, avg_pace_min_per_km, flip_count, flip_points, team_at_run, created_at, cv)")
sql.append("VALUES")

run_values = []
run_dates = ['2026-02-11', '2026-02-12', '2026-02-13', '2026-02-14', '2026-02-15']

for i in range(100):
    uid = get_uuid(i)
    
    # Determine Team and Tier
    if i < 40: # Red
        team = 'red'
        if i < 5: # Top 5
            target_flips = random.randint(150, 250)
        elif i < 20: # Mid
            target_flips = random.randint(50, 149)
        else: # Low
            target_flips = random.randint(10, 49)
    elif i < 80: # Blue
        team = 'blue'
        if i < 45: # Top 5 (40-44)
            target_flips = random.randint(120, 200)
        elif i < 60: # Mid
            target_flips = random.randint(40, 119)
        else: # Low
            target_flips = random.randint(10, 39)
    else: # Purple
        team = 'purple'
        target_flips = random.randint(10, 80)
        
    # Generate 2-5 runs
    num_runs = random.randint(2, 5)
    
    # Distribute target_flips across runs
    # We'll just generate runs that sum up roughly to target_flips
    # Or simpler: generate runs, then scale flip_points?
    # Prompt says: "flip_count: roughly (distance_km * 1.5) to (distance_km * 3)"
    # And "flip_points: flip_count * buff_multiplier"
    # So we need to reverse engineer distance from target flips.
    
    avg_flips_per_run = target_flips / num_runs
    
    for j in range(num_runs):
        run_id = get_run_uuid(i, j)
        run_date = run_dates[j % len(run_dates)] # Distribute across days
        
        # Flips for this run
        this_run_flips = int(avg_flips_per_run * random.uniform(0.8, 1.2))
        if this_run_flips < 1: this_run_flips = 1
        
        # Distance derived from flips (approx 2 flips per km)
        dist_km = this_run_flips / random.uniform(1.5, 3.0)
        if dist_km < 2.0: dist_km = 2.0
        if dist_km > 12.0: dist_km = 12.0
        
        # Recalculate flips based on clamped distance to be realistic
        final_flips = int(dist_km * random.uniform(1.5, 3.0))
        final_points = final_flips # Multiplier 1
        
        pace = random.uniform(4.5, 6.5)
        duration_sec = int(dist_km * pace * 60)
        cv = random.uniform(3.0, 15.0)
        
        start_time = f"{run_date} 08:00:00" # Simple fixed time
        end_time = f"{run_date} 09:00:00" # Placeholder, duration handled separately in column
        
        # Format SQL value
        run_values.append(f"  ('{run_id}', '{uid}', '{run_date}', '{start_time}', '{end_time}', {dist_km:.2f}, {duration_sec}, {pace:.2f}, {final_flips}, {final_points}, '{team}', NOW(), {cv:.2f})")

sql.append(",\n".join(run_values) + ";")
sql.append("")

# 7. Daily Buff Stats
sql.append("-- 7. Update daily_buff_stats")
sql.append("DELETE FROM public.daily_buff_stats WHERE stat_date BETWEEN '2026-02-12' AND '2026-02-16';")
sql.append("INSERT INTO public.daily_buff_stats (id, city_hex, stat_date, red_hex_count, blue_hex_count, purple_hex_count, dominant_team, elite_threshold_points, purple_total_users, purple_active_users, purple_participation_rate, created_at)")
sql.append("VALUES")

buff_stats = [
    # Province 8528347303
    "  (gen_random_uuid(), '8528347303', '2026-02-12', 12, 8, 3, 'red', 40, 20, 8, 40, NOW())",
    "  (gen_random_uuid(), '8528347303', '2026-02-13', 18, 12, 5, 'red', 50, 20, 10, 50, NOW())",
    "  (gen_random_uuid(), '8528347303', '2026-02-14', 22, 15, 8, 'red', 60, 20, 12, 60, NOW())",
    "  (gen_random_uuid(), '8528347303', '2026-02-15', 25, 18, 10, 'red', 70, 20, 14, 70, NOW())",
    "  (gen_random_uuid(), '8528347303', '2026-02-16', 20, 15, 14, 'red', 65, 20, 13, 65, NOW())",
    # District 89283472a9
    "  (gen_random_uuid(), '89283472a9', '2026-02-12', 5, 3, 1, 'red', 30, 5, 2, 40, NOW())",
    "  (gen_random_uuid(), '89283472a9', '2026-02-13', 6, 4, 2, 'red', 35, 5, 3, 60, NOW())",
    "  (gen_random_uuid(), '89283472a9', '2026-02-14', 7, 5, 3, 'red', 40, 5, 4, 80, NOW())",
    "  (gen_random_uuid(), '89283472a9', '2026-02-15', 8, 6, 4, 'red', 45, 5, 4, 80, NOW())",
    "  (gen_random_uuid(), '89283472a9', '2026-02-16', 7, 5, 5, 'red', 40, 5, 3, 60, NOW())"
]
sql.append(",\n".join(buff_stats) + ";")
sql.append("")

# 8. Daily All Range Stats
sql.append("-- 8. Update daily_all_range_stats")
sql.append("DELETE FROM public.daily_all_range_stats WHERE stat_date BETWEEN '2026-02-12' AND '2026-02-16';")
sql.append("INSERT INTO public.daily_all_range_stats (stat_date, dominant_team, red_hex_count, blue_hex_count, purple_hex_count, created_at)")
sql.append("VALUES")

range_stats = [
    "  ('2026-02-12', 'red', 15, 10, 4, NOW())",
    "  ('2026-02-13', 'red', 22, 15, 7, NOW())",
    "  ('2026-02-14', 'red', 28, 20, 10, NOW())",
    "  ('2026-02-15', 'red', 30, 24, 13, NOW())",
    "  ('2026-02-16', 'red', 25, 20, 18, NOW())"
]
sql.append(",\n".join(range_stats) + ";")
sql.append("")

# 9. Update Aggregates
sql.append("-- 9. Update user aggregates from run_history")
sql.append("UPDATE public.users u SET")
sql.append("  total_distance_km = agg.total_dist,")
sql.append("  avg_pace_min_per_km = agg.avg_pace,")
sql.append("  avg_cv = agg.avg_cv,")
sql.append("  total_runs = agg.run_count,")
sql.append("  cv_run_count = agg.cv_count")
sql.append("FROM (")
sql.append("  SELECT user_id,")
sql.append("    SUM(distance_km) as total_dist,")
sql.append("    CASE WHEN SUM(distance_km) > 0 THEN SUM(duration_seconds / 60.0) / SUM(distance_km) ELSE NULL END as avg_pace,")
sql.append("    AVG(cv) FILTER (WHERE cv IS NOT NULL) as avg_cv,")
sql.append("    COUNT(*) as run_count,")
sql.append("    COUNT(cv) as cv_count")
sql.append("  FROM public.run_history")
sql.append("  WHERE user_id IN (SELECT id FROM auth.users WHERE email LIKE 'bot%@runstrict.test')")
sql.append("  GROUP BY user_id")
sql.append(") agg")
sql.append("WHERE u.id = agg.user_id;")
sql.append("")
sql.append("COMMIT;")

# Write to file
with open('/Users/jaelee/.gemini/antigravity/scratch/runner/scripts/seed_simulation.sql', 'w') as f:
    f.write("\n".join(sql))

print("SQL seed script generated successfully.")
